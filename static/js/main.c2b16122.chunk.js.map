{"version":3,"sources":["components/Checker.jsx","components/Cell.jsx","components/Row.jsx","utils/initial.js","components/Board.jsx","utils/queen.js","utils/plainChecker.js","App.js","index.js","img/queen.svg"],"names":["Checker","prop","useContext","AppContext","activeChecker","toggleActive","isActive","name","onClick","className","color","isQueen","src","queen","alt","Cell","React","memo","props","checkers","turns","checkersName","moveChecker","freeCells","length","includes","checkIsActive","Row","cells","map","cell","num","key","x","y","letters","rows","row","Array","fill","item","makeRows","flat","result","i","getCellsCoords","filterCheckers","filter","Object","assign","checker","to","makeCheckers","Board","extractCoordsQueen","arr","concat","keys","getTurnCoordsQueen","params","player","coords","toBite","opposite","tmp","checkForQueen","bited","hasPerspectiveToBite","res","push","getDiagonal","left","getLeftDiagonal","right","getRightDiagonal","buildDiagonal","flag","obj","beginX","beginY","endY","before","after","xNum","indexOf","sort","endX","endx","getCFCheck","coord","counter","coords1","newCoords","ch","slice","reverse","beforeCoords","afterCoords","Set","getCoords","action","add","getBitedFields","curCoords","enemyY","enemyX","checkY","checkX","end","createContext","App","checkWinner","state","playerCheckers","setState","scanBoard","willBeBited","require","replaceChecker","field","activeCheckerProps","wasBited","toDelete","biteAgain","checkerName","prev","fields","this","prevProps","prevState","alert","toUpperCase","current","previous","join","filterPrevCoord","Provider","value","Component","ReactDOM","render","StrictMode","document","getElementById","module","exports"],"mappings":"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","file":"static/js/main.c2b16122.chunk.js","sourcesContent":["import React, { useContext } from \"react\";\nimport { AppContext } from \"../App\";\nimport queen from \"../img/queen.svg\";\n\nconst Checker = ({ prop }) => {\n  const { activeChecker, toggleActive } = useContext(AppContext);\n  const isActive = prop.name === activeChecker ? \"active\" : \"\";\n  return (\n    <div\n      onClick={() => toggleActive(prop)}\n      className={`checker ${prop.color} ${isActive}`}\n    >\n      {prop.isQueen && <img className=\"checker-icon\" src={queen} alt=\"queen\" />}\n    </div>\n  );\n};\n\nexport default Checker;\n","import React, { useContext } from \"react\";\nimport Checker from \"./Checker\";\nimport { AppContext } from \"../App\";\n\nconst checkIsActive = (turns, freeCells, name) => {\n  if (!turns || turns.length === 0) return \"\";\n  let isActive =\n    turns.includes(name) && freeCells.includes(name) ? \"active\" : \"\";\n  return isActive;\n};\n\nconst Cell = React.memo((props) => {\n  let { checkers, turns, checkersName, moveChecker, freeCells } = useContext(\n    AppContext\n  );\n  let isActive = checkIsActive(turns, freeCells, props.name);\n  return (\n    <li\n      className={`row-item ${isActive}`}\n      onClick={() => moveChecker(props, isActive)}\n    >\n      {checkersName.includes(props.name) && (\n        <Checker prop={checkers[props.name]} />\n      )}\n    </li>\n  );\n});\n\nexport default Cell;\n","import React from \"react\";\nimport Cell from \"./Cell\";\n\nconst Row = ({ cells }) => {\n  return (\n    <ul className=\"row\">\n      {cells.map((cell, num) => {\n        return <Cell key={cell.name} name={cell.name} x={cell.x} y={cell.y} />;\n      })}\n    </ul>\n  );\n};\n\nexport default Row;\n","const letters = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"];\n\nconst makeRows = () => {\n  let row = new Array(8).fill(0, 0, 8);\n  let result = row.map((item, y) => {\n    return row.map((cell, x) => {\n      return {\n        name: `${letters[x]}${y + 1}`,\n        x: y + 1,\n        y: x + 1,\n      };\n    });\n  });\n  return result;\n};\n\nlet rows = makeRows();\n\nconst getCellsCoords = (rows) => {\n  rows = rows.flat();\n  let result = {};\n  for (let i = 0; i < rows.length; i++) {\n    result[rows[i].name] = { x: rows[i].x, y: rows[i].y };\n  }\n  return result;\n};\n\nlet cells = getCellsCoords(rows);\n\nconst filterCheckers = (row, num) => {\n  let result = {};\n  row.filter((item, i) => {\n    if (num % 2 === 0) {\n      if (i % 2 === 0) result[item.name] = item;\n    } else {\n      if (i % 2 !== 0) result[item.name] = item;\n    }\n  });\n  return result;\n};\n\nconst makeCheckers = () => {\n  let result = {};\n  for (let i = 0; i < rows.length; i++) {\n    if (i <= 2 || i >= 5) {\n      result = Object.assign(result, filterCheckers(rows[i], i));\n    }\n  }\n  for (let checker in result) {\n    result[checker].color = result[checker].x <= 3 ? \"white\" : \"black\";\n    result[checker].to = result[checker].x <= 3 ? \"down\" : \"up\";\n    result[checker].isQueen = false;\n  }\n  return result;\n};\n\nconst checkers = makeCheckers();\n\nconst freeCells = [\"b4\", \"d4\", \"f4\", \"h4\", \"a5\", \"c5\", \"e5\", \"g5\"];\n\nexport { letters, rows, checkers, freeCells, cells };","import React from \"react\";\nimport Row from \"./Row\";\nimport { rows } from \"../utils/initial\";\n\nconst Board = () => (\n  <div className=\"board\">\n    {rows.map((row, num) => {\n      return <Row key={`row#${num + 1}`} cells={row} />;\n    })}\n  </div>\n);\n\nexport default Board;\n","import { letters, cells } from \"./initial\";\n\nconst filterPrevCoord = (prev, current, activeChecker) => {\n  let previous = [];\n  let turns = [];\n  for (let key in prev) {\n    for (let i = 0; i < prev[key].length; i++) {\n      previous = previous.concat(Object.keys(prev[key][i]));\n    }\n  }\n  if (current[activeChecker]) {\n    current[activeChecker] = current[activeChecker].filter((item) => {\n      let coord = Object.keys(item).join(\"\");\n      if (!previous.includes(coord)) {\n        turns.push(coord);\n        return item;\n      }\n    });\n  }\n\n  return { bited: current, turns: turns };\n};\n\nconst extractCoordsQueen = (arr) => {\n  let result = [];\n  for (let i = 0; i < arr.length; i++) {\n    result = result.concat(Object.keys(arr[i]));\n  }\n  return result;\n};\n\nconst getTurnCoordsQueen = (params) => {\n  let { freeCells, checkers, player, coords, checker } = params;\n  let turns = [];\n  let toBite = {};\n  let opposite = {};\n  for (let key in coords) {\n    let params = {\n      checker: checker,\n      coords: coords[key],\n      freeCells: freeCells,\n      checkers: checkers,\n      player: player,\n      to: key,\n    };\n    let tmp = checkForQueen(params);\n    key = key === \"left\" ? \"right\" : \"left\";\n    params = {\n      ...params,\n      coords: tmp.bited,\n      to: key,\n    };\n    opposite = hasPerspectiveToBite(params);\n    if (Object.keys(opposite).length > 0) {\n      toBite = Object.assign(toBite, opposite);\n    }\n    turns = turns.concat(tmp.turns);\n    toBite = Object.assign(toBite, tmp.bited);\n  }\n\n  if (Object.keys(toBite).length > 0) {\n    let res = [];\n    for (let y in toBite) {\n      res.push({ [y]: toBite[y] });\n    }\n    return { turns: [], toBite: res };\n  } else return { turns: turns, toBite: [] };\n};\n\nconst getDiagonal = (checker) => {\n  checker = { ...checker, x: checker.x - 1, y: checker.y - 1 };\n  return {\n    left: getLeftDiagonal(checker),\n    right: getRightDiagonal(checker),\n  };\n};\n\nconst buildDiagonal = (flag, obj) => {\n  let { beginX, beginY, endY, checker } = obj;\n  let before = [];\n  let after = [];\n  beginX = beginX + 1;\n  for (let i = beginY; i <= endY; i++) {\n    if (beginX === 0 && flag === \"right\") break;\n    let xNum = flag === \"right\" ? beginX-- : beginX++;\n    if (xNum > 8) break;\n    let name = `${letters[i]}${xNum}`;\n    checker.x + 1 > xNum ? after.push(name) : before.push(name);\n  }\n  let tmp = before.concat(after);\n  tmp = tmp.filter((item) => item.indexOf(\"undefined\") < 0);\n  return tmp.sort();\n};\n\nconst getLeftDiagonal = (checker) => {\n  let { x, y } = checker;\n  let beginX = 0;\n  let beginY = 0;\n  let endX = 0;\n  let endY = 0;\n  if (x === y) {\n    endX = 7;\n    endY = 7;\n  }\n  if (x < y) {\n    beginY = x === 0 ? y : y - x;\n    beginX = x === 0 ? 0 : x - x;\n    endY = 7;\n    endX = 7 - beginY;\n  }\n  if (x > y) {\n    beginX = x - y;\n    beginY = y - y;\n    endY = 7 - beginX;\n    endX = beginY === 0 || x === 7 ? 7 : 7 - beginY;\n  }\n  let obj = {\n    beginY: beginY,\n    beginX: beginX,\n    endY: endY,\n    endx: endX,\n    checker: checker,\n  };\n  return buildDiagonal(\"left\", obj);\n};\n\nconst getRightDiagonal = (checker) => {\n  let { x, y } = checker;\n  let beginX = 0;\n  let beginY = 0;\n  let endX = 0;\n  let endY = 0;\n  if (x === y) {\n    if (y === 0 || y === 7) beginY = y;\n    beginY = y > 0 && y <= 3 ? y - y : y - (7 - x);\n    beginY = beginY < 0 ? 0 : beginY;\n    beginX = x === 0 ? 0 : x + x;\n    beginX = beginX > 7 ? 7 : beginX;\n  }\n\n  if (x < y) {\n    if (x === 0) beginY = 0;\n    else {\n      beginY = y < 4 ? y - y : y - (7 - x);\n    }\n    beginX = y === 7 ? 7 : x + y;\n  }\n\n  if (x > y) {\n    if (x === 7) beginY = y;\n    else {\n      beginY = y === 0 ? 0 : y - (7 - x);\n    }\n    beginX = x + y;\n  }\n\n  beginX = beginX > 7 ? 7 : beginX;\n  beginY = beginY < 0 ? 0 : beginY;\n  endY = beginX;\n  endX = beginY;\n\n  let obj = {\n    beginY: beginY,\n    beginX: beginX,\n    endY: endY,\n    endx: endX,\n    checker: checker,\n  };\n  return buildDiagonal(\"right\", obj);\n};\n\nconst getCFCheck = (coord, freeCells, checkers, player) => {\n  let counter = 0;\n  let turns = [];\n  let bited = {};\n  for (let i = 0; i < coord.length; i++) {\n    if (freeCells.includes(coord[i])) {\n      if (counter > 1) break;\n      turns.push(coord[i]);\n      if (Object.keys(bited).includes(coord[i - 1])) {\n        bited[coord[i]] = bited[coord[i - 1]];\n      }\n    } else {\n      if (checkers[coord[i]]) {\n        if (checkers[coord[i]].color !== player) {\n          counter++;\n          if (counter > 1) break;\n          if (coord[i + 1] && checkers[coord[i + 1]]) {\n            if (checkers[coord[i + 1]].color === player) break;\n          }\n          if (coord[i + 1] && freeCells.includes(coord[i + 1])) {\n            if (+coord[i][1] === 8 || +coord[i][1] === 1) break;\n            if (coord[i][0] === \"a\" || coord[i][0] === \"h\") break;\n            bited[coord[i + 1]] = coord[i];\n          }\n        } else break;\n      }\n    }\n  }\n\n  return { bited: bited, turns: turns };\n};\n\nconst hasPerspectiveToBite = (params) => {\n  let { coords, freeCells, checkers, player, to } = params;\n  let coords1 = Object.keys(coords);\n  let res = {};\n  for (let i = 0; i < coords1.length; i++) {\n    let checker = {\n      name: coords1[i],\n      x: cells[coords1[i]].x,\n      y: cells[coords1[i]].y,\n      color: player,\n    };\n\n    let newCoords = getDiagonal(checker);\n    let bited = checkForQueen({\n      checker: checker,\n      coords: newCoords[to],\n      freeCells: freeCells,\n      checkers: checkers,\n      player: player,\n    });\n\n    if (Object.keys(bited.bited).length > 0) {\n      res[checker.name] = Object.keys(bited.bited);\n    }\n  }\n  return res;\n};\n\nconst checkForQueen = (params) => {\n  let { checker, coords, freeCells, checkers, player } = params;\n  let turns = [];\n  let bited = {};\n  const ch = coords.indexOf(checker.name);\n  let before = coords.slice(0, ch);\n  before = before.reverse();\n  let after = coords.slice(ch + 1);\n  let beforeCoords = getCFCheck(before, freeCells, checkers, player);\n  let afterCoords = getCFCheck(after, freeCells, checkers, player);\n  bited = Object.assign({}, beforeCoords.bited, afterCoords.bited);\n  turns = [...new Set(turns.concat(beforeCoords.turns, afterCoords.turns))];\n  return { turns: turns, bited: bited };\n};\n\nexport {\n  filterPrevCoord,\n  extractCoordsQueen,\n  getTurnCoordsQueen,\n  getDiagonal,\n  buildDiagonal,\n  getLeftDiagonal,\n};","import { letters } from \"./initial\";\n\nconst getCoords = (checker, action = \"turns\", freeCells) => {\n  let { x, y, to } = checker;\n  y = y - 1;\n  let res = [];\n  if (action === \"turns\") {\n    let add = to === \"down\" ? 1 : -1;\n    res = [`${letters[y - 1]}${x + add}`, `${letters[y + 1]}${x + add}`];\n  } else {\n    res = [\n      `${letters[y - 1]}${x + 1}`,\n      `${letters[y + 1]}${x + 1}`,\n      `${letters[y - 1]}${x - 1}`,\n      `${letters[y + 1]}${x - 1}`,\n    ];\n  }\n\n  let result = [];\n\n  for (let i = 0; i < res.length; i++) {\n    if (action === \"turns\" && !freeCells.includes(res[i])) continue;\n    if (res[i].indexOf(\"undefined\") < 0) result.push(res[i]);\n  }\n\n  return result;\n};\n\nconst getBitedFields = (checker, checkers, freeCells) => {\n  let curCoords = getCoords(checker, \"bite\", freeCells);\n  let result = {};\n  let turns = [];\n  let bited = [];\n  for (let i = 0; i < curCoords.length; i++) {\n    if (checkers[curCoords[i]]) {\n      if (checkers[curCoords[i]].color === checker.color) continue;\n      else {\n        let enemyY = checkers[curCoords[i]].y;\n        let enemyX = checkers[curCoords[i]].x;\n        let checkY = checker.y < enemyY ? enemyY + 1 : enemyY - 1;\n        let checkX = checker.x < enemyX ? enemyX + 1 : enemyX - 1;\n        let end = `${letters[checkY - 1]}${checkX}`;\n        if (end.indexOf(\"undefined\") > -1 || !freeCells.includes(end)) continue;\n        turns.push(end);\n        bited.push({ [end]: checkers[curCoords[i]].name });\n      }\n      result[checker.name] = bited;\n    }\n  }\n  return { bited: result, turns: turns };\n};\n\nexport { getCoords, getBitedFields };","import React from \"react\";\nimport \"./css/App.css\";\nimport Board from \"./components/Board\";\nimport { checkers, freeCells } from \"./utils/initial\";\nimport {\n  filterPrevCoord,\n  extractCoordsQueen,\n  getTurnCoordsQueen,\n  getDiagonal,\n} from \"./utils/queen\";\nimport { getCoords, getBitedFields } from \"./utils/plainChecker\";\n\nexport const AppContext = React.createContext();\n\nclass App extends React.Component {\n  constructor() {\n    super();\n    this.state = {\n      activeChecker: null,\n      freeCells: freeCells,\n      checkers: checkers,\n      player: \"white\",\n      turns: {},\n      toBite: {},\n    };\n  }\n\n  componentDidMount() {\n    let fields = this.scanBoard(this.state.player);\n    this.setState({ turns: fields.turns, toBite: fields.willBeBited });\n  }\n\n  checkWinner = (player) => {\n    let { checkers, toBite, turns } = this.state;\n    let playerCheckers = [];\n    for (let name in checkers) {\n      if (checkers[name].color === player) playerCheckers.push(name);\n    }\n    if (\n      playerCheckers.length === 0 || Object.keys(turns).length === 0){\n      return player;\n      }\n    else return false;\n  };\n\n  componentDidUpdate(prevProps, prevState) {\n    let { player, activeChecker, checkers, toBite } = this.state;\n    if (prevState.player !== player) {\n      let fields = this.scanBoard(player);\n      let flag = this.checkWinner(player);\n      if (!flag) {\n        this.setState({ turns: fields.turns, toBite: fields.willBeBited });\n      } else {\n        alert(`Player ${player.toUpperCase()}, you lose!!! (`);\n      }\n    } else {\n      if (activeChecker && checkers[activeChecker].isQueen) {\n        if (\n          toBite[activeChecker] &&\n          Object.keys(toBite[activeChecker]).length > 0\n        ) {\n          if (prevState.toBite !== toBite) {\n            let coords = filterPrevCoord(\n              prevState.toBite,\n              toBite,\n              activeChecker\n            );\n            if (coords.turns.length > 0) {\n              this.setState({\n                toBite: coords.bited,\n                turns: { [activeChecker]: coords.turns },\n              });\n            } else {\n              this.setState(\n                (prev) => ({\n                  player: player === \"white\" ? \"black\" : \"white\",\n                  activeChecker: null,\n                }),\n                () => this.scanBoard(this.state.player)\n              );\n            }\n          }\n        }\n      }\n    }\n  }\n\n  toggleActive = ({ name, color }) => {\n    let { player, turns } = this.state;\n    if (player === color && Object.keys(turns).includes(name)) {\n      this.setState({ activeChecker: name });\n    }\n  };\n\n  scanBoard = (color) => {\n    let turns = {};\n    let willBeBited = {};\n    let require = {};\n    let { checkers, freeCells, player } = this.state;\n    for (let key in checkers) {\n      if (checkers[key].color === color) {\n        let bited = getBitedFields(checkers[key], checkers, freeCells);\n        let coords = getCoords(checkers[key], \"turns\", freeCells);\n        if (checkers[key].isQueen) {\n          let tmp = getTurnCoordsQueen({\n            coords: getDiagonal(checkers[key]),\n            checker: checkers[key],\n            freeCells: freeCells,\n            checkers: checkers,\n            player: player,\n          });\n          if (Object.keys(tmp.toBite).length > 0) {\n            bited.turns = extractCoordsQueen(tmp.toBite);\n            bited.bited[key] = tmp.toBite;\n          } else {\n            bited.turns = tmp.turns;\n          }\n          coords = tmp.turns;\n        }\n        if (Object.keys(bited.bited).length > 0) {\n          willBeBited = { ...willBeBited, ...bited.bited };\n          require[key] = bited.turns;\n          continue;\n        }\n        if (coords.length > 0) turns[key] = coords;\n      }\n    }\n    if (Object.keys(require).length > 0)\n      return { turns: require, willBeBited: willBeBited };\n    return { turns: turns, willBeBited: willBeBited };\n  };\n\n  replaceChecker = (field) => {\n    let { activeChecker, checkers, freeCells, toBite } = this.state;\n    let activeCheckerProps = {\n      ...checkers[activeChecker],\n      name: field.name,\n      x: field.x,\n      y: field.y,\n    };\n    let wasBited = 0;\n    let toDelete = \"\";\n    if (toBite[activeChecker]) {\n      for (let i = 0; i < toBite[activeChecker].length; i++) {\n        if (Object.keys(toBite[activeChecker][i]).includes(field.name)) {\n          toDelete = toBite[activeChecker][i][field.name];\n          break;\n        }\n      }\n      delete checkers[toDelete];\n      freeCells = freeCells.filter(\n        (item) => item !== field.name && item !== toDelete\n      );\n      freeCells.push(toDelete);\n      wasBited = 1;\n    } else {\n      freeCells = freeCells.filter((item) => item !== field.name);\n    }\n    delete checkers[activeChecker];\n    checkers[field.name] = activeCheckerProps;\n    freeCells.push(activeChecker);\n    return { checkers: checkers, freeCells: freeCells, wasBited: wasBited };\n  };\n\n  biteAgain = (player, checkerName) => {\n    let { turns, willBeBited } = this.scanBoard(player);\n    if (\n      Object.keys(turns).length > 0 &&\n      Object.keys(willBeBited).includes(checkerName)\n    ) {\n      this.setState({\n        turns: turns,\n        toBite: willBeBited,\n      });\n    } else {\n      this.setState({\n        player: player === \"white\" ? \"black\" : \"white\",\n        activeChecker: null,\n      });\n    }\n  };\n\n  moveChecker = (field, isActive) => {\n    let { freeCells, player } = this.state;\n    if (freeCells.includes(field.name) && isActive === \"active\") {\n      let { checkers, freeCells, wasBited } = this.replaceChecker(field);\n      if (!checkers[field.name].isQueen) {\n        if (\n          (checkers[field.name].to === \"down\" && field.x === 8) ||\n          (checkers[field.name].to === \"up\" && field.x === 1)\n        ) {\n          checkers[field.name].isQueen = true;\n          wasBited = 1;\n        }\n      }\n      if (wasBited === 1) {\n        this.setState(\n          (prev) => ({\n            ...prev.state,\n            activeChecker: field.name,\n            checkers: checkers,\n            freeCells: freeCells,\n          }),\n          () => this.biteAgain(player, field.name)\n        );\n      } else {\n        this.setState({\n          checkers: checkers,\n          freeCells: freeCells,\n          activeChecker: null,\n          player: player === \"white\" ? \"black\" : \"white\",\n        });\n      }\n    }\n  };\n\n  render() {\n    const {\n      activeChecker,\n      checkers,\n      freeCells,\n      turns,\n      player,\n      toBite,\n    } = this.state;\n    return (\n      <AppContext.Provider\n        value={{\n          activeChecker: activeChecker,\n          checkers: checkers,\n          checkersName: Object.keys(checkers),\n          freeCells: freeCells,\n          turns: activeChecker ? turns[activeChecker] : [],\n          toBite: toBite,\n          toggleActive: this.toggleActive,\n          moveChecker: this.moveChecker,\n        }}\n      >\n        <div className=\"App\">\n          <h3>{player}</h3>\n          <Board />\n        </div>\n      </AppContext.Provider>\n    );\n  }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);","module.exports = __webpack_public_path__ + \"static/media/queen.4a25f75f.svg\";"],"sourceRoot":""}